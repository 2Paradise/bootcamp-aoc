// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");

var input = Fs.readFileSync("input/Week2/Day8Input.txt", "utf8");

var arrInput = input.split("\n");

function parseInitRecord(x) {
  var match = x.split(" ");
  if (match.length !== 2) {
    return ;
  }
  var match$1 = match[0];
  switch (match$1) {
    case "acc" :
        var v = match[1];
        return {
                isRun: false,
                operType: {
                  TAG: /* Acc */0,
                  _0: v
                },
                isLast: false,
                isCorrupted: false
              };
    case "jmp" :
        var v$1 = match[1];
        return {
                isRun: false,
                operType: {
                  TAG: /* Jmp */1,
                  _0: v$1
                },
                isLast: false,
                isCorrupted: false
              };
    case "nop" :
        var v$2 = match[1];
        return {
                isRun: false,
                operType: {
                  TAG: /* Nop */2,
                  _0: v$2
                },
                isLast: false,
                isCorrupted: false
              };
    default:
      return ;
  }
}

function parseOperation(x) {
  var accOperation = x.replace(/\d/g, "");
  var accValue = Belt_Int.fromString(x.replace(/\D/g, ""));
  return [
          accOperation,
          accValue
        ];
}

function runAcc(x, acc) {
  var match = parseOperation(x);
  var match$1 = match[0];
  if (match$1 === undefined) {
    return acc;
  }
  switch (match$1) {
    case "+" :
        var v = match[1];
        if (v !== undefined) {
          return acc + v | 0;
        } else {
          return acc;
        }
    case "-" :
        var v$1 = match[1];
        if (v$1 !== undefined) {
          return acc - v$1 | 0;
        } else {
          return acc;
        }
    default:
      return acc;
  }
}

function runJump(x, i) {
  var match = parseOperation(x);
  var match$1 = match[0];
  if (match$1 === undefined) {
    return i;
  }
  switch (match$1) {
    case "+" :
        var v = match[1];
        if (v !== undefined) {
          return i + v | 0;
        } else {
          return i;
        }
    case "-" :
        var v$1 = match[1];
        if (v$1 !== undefined) {
          return i - v$1 | 0;
        } else {
          return i;
        }
    default:
      return i;
  }
}

function checkRun(x, idx) {
  return Belt_Array.mapWithIndex(x, (function (i, x) {
                if (idx === i) {
                  return {
                          isRun: true,
                          operType: x.operType,
                          isLast: x.isLast,
                          isCorrupted: x.isCorrupted
                        };
                } else {
                  return x;
                }
              }));
}

function getExcuteAccAndIndex(operType, acc, i) {
  if (typeof operType === "number") {
    return [
            acc,
            i + 1 | 0
          ];
  }
  switch (operType.TAG | 0) {
    case /* Acc */0 :
        return [
                runAcc(operType._0, acc),
                i + 1 | 0
              ];
    case /* Jmp */1 :
        return [
                acc,
                runJump(operType._0, i)
              ];
    case /* Nop */2 :
        return [
                acc,
                i + 1 | 0
              ];
    
  }
}

function runPart1Excute(_x, _param) {
  while(true) {
    var param = _param;
    var x = _x;
    var i = param[1];
    var acc = param[0];
    var match = Caml_array.get(x, i);
    if (match.isRun) {
      return acc;
    }
    _param = getExcuteAccAndIndex(match.operType, acc, i);
    _x = checkRun(x, i);
    continue ;
  };
}

var arrExcute = Belt_Array.keepMap(Belt_Array.map(arrInput, parseInitRecord), (function (x) {
        return x;
      }));

console.log("Day 8 part1 result :: ");

console.log(runPart1Excute(arrExcute, [
          0,
          0
        ]));

var lenExcute = arrExcute.length;

function checkLast(x) {
  return Belt_Array.mapWithIndex(x, (function (i, x) {
                if ((lenExcute - 1 | 0) === i) {
                  return {
                          isRun: x.isRun,
                          operType: x.operType,
                          isLast: true,
                          isCorrupted: x.isCorrupted
                        };
                } else {
                  return x;
                }
              }));
}

function checkCorrupted(x, idx) {
  return Belt_Array.mapWithIndex(x, (function (i, x) {
                if (idx === i) {
                  return {
                          isRun: x.isRun,
                          operType: x.operType,
                          isLast: x.isLast,
                          isCorrupted: true
                        };
                } else {
                  return x;
                }
              }));
}

var arrPart2Excute = checkLast(arrExcute);

var arrCorruptedIndex = Belt_Array.keepMap(Belt_Array.mapWithIndex(arrExcute, (function (i, x) {
            var match = x.operType;
            if (typeof match === "number" || match.TAG !== /* Acc */0) {
              return i;
            }
            
          })), (function (x) {
        return x;
      }));

function changeOperType(x) {
  if (typeof x === "number") {
    return /* Not */0;
  }
  switch (x.TAG | 0) {
    case /* Acc */0 :
        return /* Not */0;
    case /* Jmp */1 :
        return {
                TAG: /* Nop */2,
                _0: x._0
              };
    case /* Nop */2 :
        return {
                TAG: /* Jmp */1,
                _0: x._0
              };
    
  }
}

function runPart2Excute(_x, _param) {
  while(true) {
    var param = _param;
    var x = _x;
    var i = param[1];
    var acc = param[0];
    var match = Caml_array.get(x, i);
    var isLast = match.isLast;
    var operType = match.operType;
    var newOperType = match.isCorrupted ? changeOperType(operType) : operType;
    if (match.isRun) {
      return [
              acc,
              isLast
            ];
    }
    if (isLast) {
      var match$1 = getExcuteAccAndIndex(newOperType, acc, i);
      return [
              match$1[0],
              isLast
            ];
    }
    _param = getExcuteAccAndIndex(newOperType, acc, i);
    _x = checkRun(x, i);
    continue ;
  };
}

function runExcute(arrCorruptedIndex, arrPart2Excute) {
  return Belt_Array.map(Belt_Array.map(arrCorruptedIndex, (function (x) {
                    return checkCorrupted(arrPart2Excute, x);
                  })), (function (x) {
                return runPart2Excute(x, [
                            0,
                            0
                          ]);
              }));
}

console.log("Day 8 part2 result :: ");

var resultPart2 = Belt_Array.get(Belt_Array.keep(runExcute(arrCorruptedIndex, arrPart2Excute), (function (param) {
            return param[1];
          })), 0);

console.log(resultPart2);

var initOperation = {
  isRun: false,
  operType: /* Not */0,
  isLast: false,
  isCorrupted: false
};

exports.input = input;
exports.initOperation = initOperation;
exports.arrInput = arrInput;
exports.parseInitRecord = parseInitRecord;
exports.parseOperation = parseOperation;
exports.runAcc = runAcc;
exports.runJump = runJump;
exports.checkRun = checkRun;
exports.getExcuteAccAndIndex = getExcuteAccAndIndex;
exports.runPart1Excute = runPart1Excute;
exports.arrExcute = arrExcute;
exports.lenExcute = lenExcute;
exports.checkLast = checkLast;
exports.checkCorrupted = checkCorrupted;
exports.arrPart2Excute = arrPart2Excute;
exports.arrCorruptedIndex = arrCorruptedIndex;
exports.changeOperType = changeOperType;
exports.runPart2Excute = runPart2Excute;
exports.runExcute = runExcute;
exports.resultPart2 = resultPart2;
/* input Not a pure module */
